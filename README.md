# **Разделы входящие в курс обучения JAVA**
# Описания раздела Java_Lesson
## Первая лекция
* Lesson_01_00 - Начало работы.
* Lesson_01_01 - Типы данных и пример объявления переменной.
* Lesson_01_02 - Варианты типов данных.
* Lesson_01_03 - Неявное преобразование.
* Lesson_01_04 - Классы-обёртки.
<details>
<summary> Дополнительные материалы.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/obert.jpg)
</details>

* Lesson_01_05 - Массивы.
* Lesson_01_06 - Преобразование.
<details>
<summary> Дополнительные материалы.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/preobr.jpg)
</details>

* Lesson_01_07 - Запрос ввода данных от пользователей в терминал.
* Lesson_01_08 - Форматированный вывод.
* Lesson_01_09 - Виды спецификаторов.
<details>
<summary> Дополнительные материалы.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/spec.jpg)
</details>

* Lesson_01_10 - Область видимости переменных.
* Lesson_01_11 - Функции и методы.
* Lesson_01_12 - Управляющие конструкции.
* Lesson_01_13 - Циклы.
* Lesson_01_14 - Работа с файлами.

## Вторая лекция
* Lesson_02_00 - Что такое API.

<details>
<summary> Дополнительные материалы.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/str1.jpg)
</details>

* Lesson_02_01 - Работа с файловой системой.

<details>
<summary> Дополнительные материалы.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/fail1.jpg)
</details>

* Lesson_02_02 - Логирование.
* Lesson_02_03 - Импорт.
* Lesson_02_04 - Xml.

#
## Третья лекция
* Lesson_03_00 - Object.
* Lesson_03_01 - Массивы.

<details>
<summary> Дополнительные материалы.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/mas1.jpg)![](Dop_materiali(jpg)/mas2.jpg)![](Dop_materiali(jpg)/mas3.jpg)
![](Dop_materiali(jpg)/mas4.jpg)![](Dop_materiali(jpg)/mas5.jpg)![](Dop_materiali(jpg)/mas6.jpg)![](Dop_materiali(jpg)/mas7.jpg)![](Dop_materiali(jpg)/mas8.jpg)![](Dop_materiali(jpg)/mas9.jpg)![](Dop_materiali(jpg)/mas10.jpg)![](Dop_materiali(jpg)/mas11.jpg)![](Dop_materiali(jpg)/mas12.jpg)
</details>

* Lesson_03_02 - Листы.

<details>
<summary> Дополнительные материалы.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/list1.jpg)![](Dop_materiali(jpg)/list2.jpg)
</details>

* Lesson_03_03 - Коллекции. Функционал.

<details>
<summary> Дополнительные материалы.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/fun1.jpg)![](Dop_materiali(jpg)/fun2.jpg)
</details>

* Lesson_03_04 - Итератор.
<details>
<summary> Дополнительные материалы.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/it.jpg)
</details>

#
## Четвёртая лекция

<details>
<summary>LinkedList</summary>

![Дополнительные материалы](Dop_materiali(jpg)/Llisst1.jpg)![](Dop_materiali(jpg)/Llisst2.jpg)![](Dop_materiali(jpg)/Llisst3.jpg)![](Dop_materiali(jpg)/Llisst4.jpg)![](Dop_materiali(jpg)/Llisst5.jpg)![](Dop_materiali(jpg)/Llisst6.jpg)![](Dop_materiali(jpg)/Llisst7.jpg)![](Dop_materiali(jpg)/Llisst8.jpg)![](Dop_materiali(jpg)/Llisst9.jpg)![](Dop_materiali(jpg)/Llisst10.jpg)![](Dop_materiali(jpg)/Llisst11.jpg)![](Dop_materiali(jpg)/Llisst12.jpg)![](Dop_materiali(jpg)/Llisst13.jpg)![](Dop_materiali(jpg)/Llisst14.jpg)![](Dop_materiali(jpg)/Llisst15.jpg)
</details>

<details>
<summary> Lesson_04_01 - Queue.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/q1.jpg)![](Dop_materiali(jpg)/q2.jpg)![](Dop_materiali(jpg)/q3.jpg)![](Dop_materiali(jpg)/q4.jpg)![](Dop_materiali(jpg)/q5.jpg)![](Dop_materiali(jpg)/q6.jpg)
</details>

<details>
<summary> Lesson_04_02 - PriorityQueue.</summary>

</details>

<details>
<summary> Lesson_04_03 - Deque – double ended queue.</summary>

</details>

<details>
<summary> Lesson_04_04 - Stack.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/st.jpg)
</details>

#
## Пятая лекция
* Lesson_05_00 - HashMa.
* Lesson_05_01 - HashMap. Важное дополнение.
Работа с парами.
* Lesson_05_02 - HashMap. Важное дополнение. Скорость.Как ускорить работу.

<details>
<summary> Дополнительные материалы.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/hm1.jpg)![](Dop_materiali(jpg)/hm2.jpg)![](Dop_materiali(jpg)/hm3.jpg)![](Dop_materiali(jpg)/hm4.jpg)![](Dop_materiali(jpg)/hm5.jpg)![](Dop_materiali(jpg)/hm6.jpg)![](Dop_materiali(jpg)/hm7.jpg)![](Dop_materiali(jpg)/hm8.jpg)![](Dop_materiali(jpg)/hm9.jpg)![](Dop_materiali(jpg)/hm10.jpg)![](Dop_materiali(jpg)/hm11.jpg)![](Dop_materiali(jpg)/hm12.jpg)![](Dop_materiali(jpg)/hm13.jpg)
</details>

* Lesson_05_03 - TreeMap.

<details>
<summary> Дополнительные материалы.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/tm1.jpg)![](Dop_materiali(jpg)/tm2.jpg)![](Dop_materiali(jpg)/tm3.jpg)!
</details>

* Lesson_05_04 - LinkedHashMap.

<details>
<summary> Дополнительные материалы.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/lm1.jpg)
</details>

* Lesson_05_05 - HashTable.

#
## Шестая лекция

<details>
<summary>Иерархия коллекций.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/set0.jpg)
</details>

#
* Lesson_06_00 - HashSet.

<details>
<summary> Дополнительные материалы.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/hset0.jpg)
</details>

* Lesson_06_01 - HashSet как синоним множества.

<details>
<summary> Дополнительные материалы.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/hset1.jpg)
</details>

* Lesson_06_02 - TreeSet.

<details>
<summary> Дополнительные материалы.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/tset1.jpg)![Дополнительные материалы](Dop_materiali(jpg)/tset2.jpg)
</details>

* Lesson_06_03 - LinkedHashSet.

<details>
<summary> Дополнительные материалы.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/lset1.jpg)
</details>

* Lesson_06_04-05 - Введение в создание собственных типов.

<details>
<summary> Дополнительные материалы.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/vset1.jpg)![Дополнительные материалы](Dop_materiali(jpg)/vset2.jpg)
</details>

#
## Седьмая лекция
* ООП - Объектно ориентированное программирование

<details>
<summary> Дополнительные материалы.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/oop1.jpg)![Дополнительные материалы](Dop_materiali(jpg)/oop2.jpg)![Дополнительные материалы](Dop_materiali(jpg)/oop3.jpg)![Дополнительные материалы](Dop_materiali(jpg)/oop4.jpg)![Дополнительные материалы](Dop_materiali(jpg)/oop5.jpg)![Дополнительные материалы](Dop_materiali(jpg)/oop6.jpg)![Дополнительные материалы](Dop_materiali(jpg)/oop7.jpg)
</details>

* Lesson_07_00 - 07_06 Примеры от меньшего к большему.

#
## Восьмая лекция
<details>
<summary> Lesson_08_00 - Абстракция.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/Abs1.jpg)![Дополнительные материалы](Dop_materiali(jpg)/Abs2.jpg)
</details>

<details>

<summary> Lesson_08_01,02,03,04 - Интерфейсы.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/int1.jpg)![Дополнительные материалы](Dop_materiali(jpg)/int2.jpg)![Дополнительные материалы](Dop_materiali(jpg)/int3.jpg)
</details>
Lesson_08_05 - Сложный пример!

#
## Девятая лекция 
* Lesson_09_00 - Iterator<E>
* Lesson_09_01 - Iterable<E>
* Lesson_09_02 - Comparator<E>
* Lesson_09_03 - Comparable<E>
* Lesson_09_04 - Comparable, equals, ==
* Lesson_09_05 - foreach для своих типов
<details>
<summary> Дополнительные материалы.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/l9_1.jpg)![Дополнительные материалы](Dop_materiali(jpg)/l9_2.jpg)![Дополнительные материалы](Dop_materiali(jpg)/l9_3.jpg)![Дополнительные материалы](Dop_materiali(jpg)/l9_4.jpg)
</details>

#
## Деcятая лекция
* Параметризованные типы. Классы и Методы.
* Построение иерархий обобщений.
* Lesson_10_00,01,02,03,04,05,06,07 - Примеры использования.

#
## Одинадцатая лекция.
* ООП: От простого
к практике
<details>
<summary> Задача 1 - Ex001Calc.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/z1.jpg)![Дополнительные материалы](Dop_materiali(jpg)/mvp11.jpg)
</details>

<details>
<summary> Задача 2 - Ex002Phonebook.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/z2.jpg)
</details>

<details>
<summary> Задача 3 - Ex003Math.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/z3.1.jpg)![Дополнительные материалы](Dop_materiali(jpg)/z3.2.jpg)![Дополнительные материалы](Dop_materiali(jpg)/z3.3.jpg)
</details>

#
## Двенадцатая лекция.

<details>
<summary> ООП: SOLID.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/L12G.jpg)
</details>

<details>
<summary> Реализация Ex001_1SRP - Ex001_2SRP.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/L12.1.jpg)
</details>

<details>
<summary> Реализация Ex002_1OCP - Ex002_2OCP.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/L12.2.jpg)
</details>

<details>
<summary> Реализация Ex003_1LSP - Ex003_2LSP.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/L12.3.jpg)
</details>

<details>
<summary> Реализация Ex004_1ISP - Ex004_2ISP.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/L12.4.jpg)
</details>

<details>
<summary> Реализация Ex005_1DIP - Ex005_2DIP.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/L12.5.jpg)
</details>

#
# Описания раздела тем Java_Seminar
## Первый семминар
* Seminar_01_00 - Решение задач

<details>
<summary> 
Задача 0 - task0
</summary>
Написать программу, которая запросит пользователя ввести <Имя> в консоли. 
Получит введенную строку и выведет в консоль сообщение “Привет, <Имя>!”
</details> 

<details>
<summary> 
Задача 1 - task1
</summary>
В консоли запросить имя пользователя. 
В зависимости от текущего времени, вывести приветствие вида 
"Доброе утро, <Имя>!", если время от 05:00 до 11:59
"Добрый день, <Имя>!", если время от 12:00 до 17:59;
"Добрый вечер, <Имя>!", если время от 18:00 до 22:59;
"Доброй ночи, <Имя>!", если время от 23:00 до 4:59 “Привет, <Имя>!”
</details>

<details>
<summary> 
Задача 2 - task3
</summary>
Дан массив двоичных чисел, например [1,1,0,1,1,1], 
вывести максимальное количество подряд идущих 1.
</details>

<details>
<summary> 
Задача 3 - task3
</summary>
Дан массив nums = [3,2,2,3] и число val = 3. 
Если в массиве есть числа, равные заданному, 
нужно перенести эти элементы в конец массива. 
Таким образом, первые несколько (или все) 
элементов массива должны быть отличны от заданного, а остальные - равны ему.
</details>

<details>
<summary> 
Задача 4 - task4
</summary>
Напишите метод, который находит самую длинную строку общего префикса среди массива строк.
Если общего префикса нет, вернуть пустую строку "".
</details>

#
## Второй семминар
* Seminar_02_00.java - Решение задач(файл для запуска программ).

<details>
<summary> 
Задача 1 - task1
</summary>
Дано четное число N (>0) и символы c1 и c2.
Написать метод, который вернет строку длины N, которая
состоит из чередующихся символов c1 и c2, начиная с c1.
</details> 

<details>
<summary> 
Задача 2 - task2
</summary>
Напишите метод, который сжимает строку.
Пример: вход aaaabbbcdd.
</details>

<details>
<summary> 
Задача 3 - task3
</summary>
Напишите метод, который составит строку, состоящую из 100
повторений слова TEST и метод, который запишет эту строку в
простой текстовый файл, обработайте исключения.
</details>

<details>
<summary> 
Задача 4 - task4
</summary>
Напишите метод, который вернет содержимое текущей папки в виде
массива строк.
📌 Напишите метод, который запишет массив, возвращенный предыдущим
методом в файл.
📌 Обработайте ошибки с помощью try-catch конструкции. В случае
возникновения исключения, оно должно записаться в лог-файл.
📌 А также Напишите метод, который определит тип (расширение) файлов из
текущей папки и выведет в консоль результат вида
1 Расширение файла: txt
2 Расширение файла: pdf
3 Расширение файла:
4 Расширение файла: jpg
</details>

#
## Третий семминар
* Seminar_03 - Решение задач(файл для запуска программ)

<details>
<summary> 
Задача 0 - task0
</summary>
Даны следующие строки, cравнить их с помощью == и
метода equals() класса Object
String s1 = "hello";
String s2 = "hello";
String s3 = s1;
String s4 = "h" + "e" + "l" + "l" + "o";
String s5 = new String("hello");
String s6 = new String(new char[]{'h', 'e', 'l', 'l', 'o'});
</details>

<details>
<summary> 
Задача 1 - task1
</summary>
Заполнить список десятью случайными числами.
Отсортировать список методом sort() и вывести его на
экран.
</details>

<details>
<summary> 
Задача 2 - task2
</summary>
Заполнить список названиями планет Солнечной
системы в произвольном порядке с повторениями.
Вывести название каждой планеты и количество его
повторений в списке.
</details>

<details>
<summary> 
Задача 3 - task3
</summary>
Создать список типа ArrayList<String>.
Поместить в него как строки, так и целые числа.
Пройти по списку, найти и удалить целые числа.
</details>

<details>
<summary> 
Задача 4 - task4
</summary>
Каталог товаров книжного магазина сохранен в виде двумерного
списка List<ArrayList<String>> так, что на 0й позиции каждого
внутреннего списка содержится название жанра, а на остальных
позициях - названия книг. Напишите метод для заполнения данной
структуры.
</details>

#
## Четвёртый семминар
* Seminar_04 - Решение задач(файл для запуска программ)

<details>
<summary> 
Задача 0 - task0
</summary>
1. Замерьте время, за которое в ArrayList добавятся 10000 элементов.
2. Замерьте время, за которое в LinkedList добавятся 10000 элементов.
Сравните с предыдущим.
</details>

<details>
<summary> 
Задача 1 - task1
</summary>

# Реализовать консольное приложение, которое:
1. Принимает от пользователя строку вида
text~num
2. Нужно рассплитить строку по ~, сохранить text в связный список на
позицию num.
3. Если введено print~num, выводит строку из позиции num в связном
списке и удаляет её из списка.
4. Принимает от пользователя и “запоминает” строки.
5. Если введено print, выводит строки так, чтобы последняя введенная
была первой в списке, а первая - последней.
6. Если введено revert, удаляет предыдущую введенную строку из памяти.
</details>

#
## Пятый семминар
* Seminar_05 - Решение задач (файл для запуска программ)

<details>
<summary> 
Задача 0 - task0
</summary>
Создать структуру для хранения Номеров паспортов и Фамилий сотрудников организации.
123456 Иванов
321456 Васильев
234561 Петрова
234432 Иванов
654321 Петрова
345678 Иванов
Вывести данные по сотрудникам с фамилией Иванов.
</details>

<details>
<summary> 
Задача1  - task1
</summary>

Написать программу, определяющую правильность расстановки скобок в выражении.
1. Пример: a+(d*3) - истина
2. Пример: [a+(1*3) - ложь
3. Пример: [6+(3*3)] - истина
4. Пример: {a}[+]{(d*3)} - истина
5. Пример: <{a}+{(d*3)}> - истина
6. Пример: {a+]}{(d*3)} - ложь.
</details>

<details>
<summary> 
Задача2  - task2
</summary>

Взять набор строк, например,
Мороз и солнце день чудесный Еще ты дремлешь друг прелестный Пора красавица проснись.
Написать метод, который отсортирует эти строки по длине с помощью TreeMap. 
Строки с одинаковой длиной не должны “потеряться”.
</details>

#
## Шестой семминар

<details>
<summary> 
task0.java
</summary>

1. Создайте HashSet, заполните его следующими числами: {1, 2, 3, 2, 4, 5, 6, 3}. 
Распечатайте содержимое данного множества.
2. Создайте LinkedHashSet, заполните его следующими числами: 
{1, 2, 3, 2, 4, 5, 6, 3}.  Распечатайте содержимое данного множества.
3. Создайте TreeSet, заполните его следующими числами: 
{1, 2, 3, 2, 4, 5, 6, 3}.Распечатайте содержимое данного множества.
</details>

#
## Седьмой семминар.
* Принципы ООП: Инкапсуляция, наследование, полиморфизм.
* Принципы ООП Абстракция и интерфейсы. Пример проектирования.
* Semminar7 - Написать программу торгового автомата напитко.  

#
## Восьмой семминар.
* Повторим теорию базовых определений ООП - абстракция, наследование.
* Задание 1 - Интерфейс ActorBehavoir,
который будет содержать
описание возможных
действий актора в
очереди/магазине
* Абстрактный класс Actor,
который хранит в себе
параметры актора, включая
состояние готовности сделать
заказ и факт получения
заказа. Дополнение: для большего понимания, можно сделать методы-геттеры для имени и прочих
“персональных данных” abstract
* Класс Human, который должен наследоваться от Actor и реализовывать ActorBehavoir
* Задание 2 - Необходимо реализовать строение классов, без
конкретной реализации:
* Интерфейс QueueBehaviour, который описывает
логику очереди – помещение в/освобождение из
очереди, принятие/отдача заказа.
* Интерфейс MarketBehaviour, который описывает
логику магазина – приход/уход покупателей,
обновление состояния магазина.
* Класс Market, который реализовывает два
вышеуказанных интерфейса и хранит в списке
список людей в очереди в различных статусах.
* Seminar8 - реализация.

#
## Девятый семминар.
* Повторим теорию, пройденную на предыдущем семинаре - интерфейсы.
* Задача 1 - Iterator
📌 Создать класс Студент
📌 Создать класс УчебнаяГруппа
📌 Создать класс УчебнаяГруппаИтератор, заставив его реализовать
интерфейс Iterator
📌 Реализовать его контракты (включая удаление)
* Задача 2 - Iterable
📌 Модифицировать класс УчебнаяГруппа, заставив его реализовать
интерфейс Iterable
📌 Реализовать метод iterator() возвращающий экземпляр созданного нами
итератора
📌 Создать класс УчебнаяГруппаСервис, добавив в него метод удаления
студента по ФИО
📌 Создать класс Контроллер, добавив в него метод удаления студента и
вызывать в нем созданный метод из УчебнаяГруппаСервис
* Задача 3 - Comparable
📌 Модифицировать класс Студент, заставив его реализовать интерфейс
Comparable
📌 Реализовать контракт compareTo () со сравнением по какому-либо
параметру (пример studentId)
📌 Модифицировать класс УчебнаяГруппаСервис, добавив в него метод
сортировки списка студентов по id
📌 Модифицировать класс Контроллер, добавив в него метод сортировки
списка студентов по id и вызывать в нем созданный метод из
УчебнаяГруппаСервис
* Задача 4 - Comparator
📌 Создать класс СтудентКомпаратор реализующий интерфейс Comparator
📌 Реализовать контракт compare () со сравнением по какому-либо параметру
(пример: сочетание Имя+Фамилия)
📌 Модифицировать класс УчебнаяГруппаСервис, добавив в него метод
сортировки списка студентов по ФИО
📌 Модифицировать класс Контроллер, добавив в него метод сортировки
списка студентов по ФИО и вызывать в нем созданный метод из
УчебнаяГруппаСервис.
* Seminar9 - реализация.

#
## Десятый семминар.
* Задача 2.1
1. Создать класс Юзер и перенести его в базовые поля (ФИО)
2. Модифицировать ранее созданный класс СтудентКомпаратор
• Переименовать в ЮзерКомпаратор
• Типизировать его T наследующегося от типа Юзер
• Типизировать реализуемый интерфейс Компаратор T
• Изменить метод компаре, внеся во входные данные вместо конкретных классов
типизацию T
• Внести правки места, где использовался предыдущий компаратор
* Задача 2.2
1. Разработать обобщенный метод вычисления среднеарифметического
массива
2. Разработать обобщенный метод выплаты работникам защищенный по
типу.
* Задача 2.3
1. Модифицировать ранее созданный класс ЮзерКонтроллер
•Сделать его интерфейсом
•Типизировать его T наследующегося от типа Юзер
•Внести в метод create типизацию
2. Создать класс СтудентКонтроллер реализующий созданный интерфейс
•Внести правки в метод create согласно типизации
•Перенести в него ранее созданные другие методы (включая те, которые могли быть
созданы в процессе домашней работы)
•Изменить используемый сервис внутри конроллера на ранее созданны
СтудентСервис
•Изменить используемый вью внутри конроллера на ранее созданны СтудентВью.
* Seminar10 - реализация.


#
## Одинадцатый семминар.
Цели на семинар:
1. 📌 повторить теорию, пройденную на предыдущем семинаре – абстракция, интерфейсы
2. 📌 получить практические навыки в проектировании приложения
3. 📌 научить проектировать MVC приложения с необходимым уровнем абстракции
4. Seminar11 - Реализация практики.

#
## Двенадцатый семминар.
Цели на семинар:
- 📌 Получим понимание принципов SOLID
- 📌 Научимся понимать проблемные места кода и архитектуры используя принципы SOLID
- 📌 Реализация практической части небыло, только теоритическая.

<details>
<summary> Дополнительные материалы.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/s12.1.jpg)![Дополнительные материалы](Dop_materiali(jpg)/s12.2.jpg)![Дополнительные материалы](Dop_materiali(jpg)/s12.3.jpg)![Дополнительные материалы](Dop_materiali(jpg)/s12.4.jpg)![Дополнительные материалы](Dop_materiali(jpg)/s12.5.jpg)![Дополнительные материалы](Dop_materiali(jpg)/s12.6.jpg)
</details>

#
## Тринадцатый семминар.
Цели на семинар:
- 📌 Рассуждения о том, что все, что здесь изучили применимо для других языков
программирования
- 📌 Паттерны проектирования, что это такое и зачем они нужны
- 📌 Задания по модернизации кода согласно SOLID и паттернов
- Практика - Реализация.

<details>
<summary> Seminar13 - Adapter.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/ad13.jpg)
</details>

<details>
<summary> Seminar13 - Decorator.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/dt13.jpg)
</details>

<details>
<summary> Seminar13 - Factory.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/fm13.jpg)
</details>

<details>
<summary> Seminar13 - Observer.</summary>

![Дополнительные материалы](Dop_materiali(jpg)/ob13.jpg)
</details>


#
# Java_DZ
**Задание и выполнение домашней работы dz_01**
* dz_01_00.java
<details>
<summary> 
Задача 0 - task0
</summary>
Вычислить сумма чисел от 1 до n.
</details>

<details>
<summary> 
Задача 1 - task1
</summary>
Вывести все простые числа от 1 до 1000.
</details>

<details>
<summary> 
Задача 2 - task2
</summary>
Реализовать простой калькулятор.
</details>

#
**Задание и выполнение домашней работы dz_02**

<details>
<summary> 
dz_02_00.java
</summary>
Дана строка sql-запроса "select * from students where ". 
Сформируйте часть WHERE этого запроса, используя StringBuilder. 
Данные для фильтрации приведены ниже в виде json-строки.
Если значение null, то параметр не должен попадать в запрос.
Параметры для фильтрации: {"name":"Ivanov", "country":"Russia", "city":"Moscow", "age":"null"}.
</details>

<details>
<summary> 
dz_02_01.java
</summary>
Реализуйте алгоритм сортировки пузырьком числового массива, 
результат после каждой итерации запишите в лог-файл..
</details>

#
**Задание и выполнение домашней работы dz_03**
* dz_zap_03.java - для запуска задач.

<details>
<summary> 
task0.java
</summary>
Реализовать алгоритм сортировки слиянием.
</details>

<details>
<summary> 
task1.java
</summary>
Пусть дан произвольный список целых чисел, удалить из него четные числа.
</details>

<details>
<summary> 
task1.java
</summary>
Задан целочисленный список ArrayList. Найти минимальное, максимальное и среднее из этого списка.
</details>

#
**Задание и выполнение домашней работы dz_04**
* dz_zap_04.java - для запуска задач.

<details>
<summary> 
task0.java
</summary>

**Текст задачи:**
Реализовать консольное приложение, которое:

1. Принимает от пользователя строку вида text~num

1. Нужно рассплитить строку по ~, сохранить text в связный список на позицию num.
2. Если введено print~num, выводит строку из позиции num в связном списке и удаляет её из списка.

**Текст задачи:**
Реализовать консольное приложение, которое:

1. Принимает от пользователя и “запоминает” строки.
2. Если введено print, выводит строки так, чтобы последняя введенная была первой в списке, а первая - последней.
3. Если введено reverse, вывести список в обратном порядке.
</details>

<details>
<summary> 
task1.java
</summary>

Реализуйте очередь с помощью LinkedList со следующими методами:
1. enqueue() - помещает элемент в конец очереди, 
2. dequeue() - возвращает первый элемент из очереди и удаляет его, 
3. first() - возвращает первый элемент из очереди, не удаляя.
</details>

#
**Задание и выполнение домашней работы dz_05**
* dz_zap_05.java - для запуска программы.

<details>
<summary> 
task0.java
</summary>

1. Реализуйте структуру телефонной книги с помощью HashMap. Программа также должна учитывать, что во входной структуре будут повторяющиеся имена с разными телефонами, их необходимо считать, как одного человека с разными телефонами. Вывод должен быть отсортирован по убыванию числа телефонов.(можно выводить без сортировки, но обязательно в отдельном методе).
</details>

<details>
<summary> 
task1.java
</summary>

1. Реализовать алгоритм пирамидальной сортировки (HeapSort)(найти метод в Интернете и включить в проект).
</details>

#
**Задание и выполнение домашней работы dz_06**
* task.java - для запуска программы.

<details>
<summary> 
laptop.java
</summary>

1. Подумать над структурой класса Ноутбук(или Единорогов) для магазина техники - выделить поля и методы. Реализовать в java.
Создать множество ноутбуков.
Переопределить toString, equals и hashCode(как на семинаре).
Вывести на печать экземпляры класса, сравнить пару экземпляров и найти один экземпляр в наборе.
</details>

#
**Задание и выполнение домашней работы dz_07**

<details>
<summary> 
Файл для запуска программы dz_zap_07.java
</summary>

1. Создать наследника Product реализовать класс ГорячийНапиток(Hot Drink) с дополнительным полем int температура.
2. Для класса ГорячихНапитков(Hot Drink) написать конструктор и переопределить метод toString()
3. В main добавить в автомат несколько ГорячихНапитков(Hot Drink) и воспроизвести логику заложенную в программе
</details>

#
**Задание и выполнение домашней работы dz_08**

<details>
<summary> 
Файл для запуска программы java_dz.main.java
</summary>

1. Добавить класс, описывающий акционного клиента. Включить поле название акции, id клиента и количество участников в акции(поле статическое).
2. Добавить интерфейс iReturnOrder возврата товара. Продумать какие методы могут понадобиться и подключить интерфейс к классам клиентов.
3. Добавить комментарии(javadoc) ко всем методам и интерфейсам.
</details>

#
**Задание и выполнение домашней работы dz_09**

<details>
<summary> 
Файл для запуска программы java_dz.dz_09.main.java
</summary>

1. Создать класс StudentSteam(поток студентов с полем номер потока) содержащий в себе список учебных групп(StudentGroup).
2. Для класса StudentSteam реализовать интерфейс Iterable и вывести через for несколько групп со списком студентов на кансоль.
3. Для класса StudentGroup реализовать интерфейс Comparable(сортировка по количеству студентов в группе) и отсортировать группы студентов в потоке, а затем вывести в консоль.
</details>

#
**Задание и выполнение домашней работы dz_10**

<details>
<summary> 
Файл для запуска программы java_dz.dz_10.main.java
</summary>

1. Создать класс TeacherService и реализовать аналогично проделанному на семинаре. Подключить обобщенный интерфейс iPersonService. Добавить метод вывода списка учителей отсортированного обобщенным классом PersonComparator.
2. Создать класс TeacherController. Подключить к классу обобщенный интерфейс iPersonController.
3. Разработать обобщенный класс AverageAge для подсчета среднего возраста студентов, учителей и работников. Вывести результат работы класса на консоль.
</details>

#
**Задание и выполнение домашней работы dz_11**

<details>
<summary> 
Файл для запуска программы java_dz.dz_11.main.java
</summary>

1. Сделать вариант класса ViewEng с текстом на английском языке, подключить к нему интерфейс iGetView. Класс ViewEng подключить к контроллеру.
2. Сделать вариант класса hachModel с хранилищем типа HashMap<Long,Student>, подключить к нему интерфейс iGetModel. Класс подключить к контроллеру.
3. Добавить команду в метод run класса контролер по удалению студента:
Для этого: Добавить в switch команду DELETE
- запросить у пользователя номер студента на удаление
- вызов удаления у модели(метод добавить в интерфейс iGetModel)
- если такого нромера нет, то сообщить об этом
Весь код прокомментировать и добавить само-документацию.
</details>

#
**Задание и выполнение домашней работы dz_12**

* Файл для запуска всех задач - dz_12_main.

<details>
<summary> 
Задача № 1 - task1_SRP.
</summary>

- Переписать код в соответствии с Single Responsibility Principle:

- public class Employee {
private String name;
private Date dob;
private int baseSalary;
public Employee(String name, Date dob, int baseSalary) {
this.name = name;
this.dob = dob;
this.baseSalary = baseSalary;
}
public String getEmpInfo() {
return "name - " + name + " , dob - " + dob.toString();
}
public int calculateNetSalary() {
int tax = (int) (baseSalary * 0.25);//calculate in otherway
return baseSalary - tax;
}
}
​
- Подсказка: вынесите метод calculateNetSalary() в отдельный класс
</details>

<details>
<summary> 
Задача № 2 - task2_OCP.
</summary>

- Переписать код SpeedCalculation в соответствии с Open-Closed Principle:

- public class SpeedCalculation {
public double calculateAllowedSpeed(Vehicle vehicle) {
if (vehicle.getType().equalsIgnoreCase("Car")) {
return vehicle.getMaxSpeed() * 0.8;
} else if (vehicle.getType().equalsIgnoreCase("Bus")) {
return vehicle.getMaxSpeed() * 0.6;
}
​
return 0.0;
}
}
public class Vehicle {
int maxSpeed;
String type;
public Vehicle(int maxSpeed, String type) {
this.maxSpeed = maxSpeed;
this.type = type;
}
public int getMaxSpeed() {
return this.maxSpeed;
}
public String getType() {
return this.type;
}
}
​
- Подсказка: создайте два дополнительных класса Car и Bus(наследников Vehicle), 
напишите метод calculateAllowedSpeed(). 
Использование этого метода позволит сделать класс SpeedCalculation соответствующим OCP.
</details>

<details>
<summary> 
Задача № 3 - task3_ISP.
</summary>

- Переписать код в соответствии с Interface Segregation Principle:

- public interface Shape {
double area();
double volume();
}
public class Circle implements Shape {
private double radius;
public Circle(double radius) {
this.radius = radius;
}
@Override
public double area() {
return 2 * 3.14 * radius;
}
@Override
public double volume() {
throw new UnsupportedOperationException();
}
}
public class Cube implements Shape {
private int edge;
public Cube(int edge) {
this.edge = edge;
}
@Override
public double area() {
return 6 * edge * edge;
}
@Override
public double volume() {
return edge * edge * edge;
}
}
​
- Подсказка: круг не объемная фигура и этому классу не нужен метод volume().
</details>

#
# Dop_materiali(jpg)
* **Дополнительные материалы, скрины картинки к темам занятий**

